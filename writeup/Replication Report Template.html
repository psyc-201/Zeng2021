<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Chattarin Poungtubtim (cpoungtubtim@ucsd.edu)">
<meta name="dcterms.date" content="2025-11-05">

<title>Replication of Study Tracking the relation between gist and item memory over the course of long-term memory consolidation by Tima Zeng et al.&nbsp;(2021, eLife)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Replication Report Template_files/libs/clipboard/clipboard.min.js"></script>
<script src="Replication Report Template_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Replication Report Template_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Replication Report Template_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="Replication Report Template_files/libs/quarto-html/popper.min.js"></script>
<script src="Replication Report Template_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Replication Report Template_files/libs/quarto-html/anchor.min.js"></script>
<link href="Replication Report Template_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Replication Report Template_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Replication Report Template_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Replication Report Template_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Replication Report Template_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a>
  <ul class="collapse">
  <li><a href="#power-analysis" id="toc-power-analysis" class="nav-link" data-scroll-target="#power-analysis">Power Analysis</a></li>
  <li><a href="#planned-sample" id="toc-planned-sample" class="nav-link" data-scroll-target="#planned-sample">Planned Sample</a></li>
  <li><a href="#materials" id="toc-materials" class="nav-link" data-scroll-target="#materials">Materials</a></li>
  <li><a href="#procedure-i-just-sent-an-email-to-corresponding-author-for-more-details-on-how-to-code-an-experiment.-i-will-put-in-more-details-when-i-get-more-information" id="toc-procedure-i-just-sent-an-email-to-corresponding-author-for-more-details-on-how-to-code-an-experiment.-i-will-put-in-more-details-when-i-get-more-information" class="nav-link" data-scroll-target="#procedure-i-just-sent-an-email-to-corresponding-author-for-more-details-on-how-to-code-an-experiment.-i-will-put-in-more-details-when-i-get-more-information">Procedure (I just sent an email to corresponding author for more details on how to code an experiment. I will put in more details when I get more information !)</a></li>
  <li><a href="#analysis-plan" id="toc-analysis-plan" class="nav-link" data-scroll-target="#analysis-plan">Analysis Plan</a></li>
  <li><a href="#reliability-and-validity" id="toc-reliability-and-validity" class="nav-link" data-scroll-target="#reliability-and-validity">Reliability and validity</a></li>
  <li><a href="#differences-from-original-study" id="toc-differences-from-original-study" class="nav-link" data-scroll-target="#differences-from-original-study">Differences from Original Study</a></li>
  <li><a href="#methods-addendum-post-data-collection" id="toc-methods-addendum-post-data-collection" class="nav-link" data-scroll-target="#methods-addendum-post-data-collection">Methods Addendum (Post Data Collection)</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a>
  <ul class="collapse">
  <li><a href="#data-preparation" id="toc-data-preparation" class="nav-link" data-scroll-target="#data-preparation">Data preparation</a></li>
  <li><a href="#confirmatory-analysis" id="toc-confirmatory-analysis" class="nav-link" data-scroll-target="#confirmatory-analysis">Confirmatory analysis</a></li>
  <li><a href="#exploratory-analyses" id="toc-exploratory-analyses" class="nav-link" data-scroll-target="#exploratory-analyses">Exploratory analyses</a></li>
  </ul></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a>
  <ul class="collapse">
  <li><a href="#summary-of-replication-attempt" id="toc-summary-of-replication-attempt" class="nav-link" data-scroll-target="#summary-of-replication-attempt">Summary of Replication Attempt</a></li>
  <li><a href="#commentary" id="toc-commentary" class="nav-link" data-scroll-target="#commentary">Commentary</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Replication of Study Tracking the relation between gist and item memory over the course of long-term memory consolidation by Tima Zeng et al.&nbsp;(2021, eLife)</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Chattarin Poungtubtim (cpoungtubtim@ucsd.edu) </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 5, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<!-- Replication reports should all use this template to standardize reporting across projects.  These reports will be public supplementary materials that accompany the summary report(s) of the aggregate results. -->
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>The reason I chose this paper to replicate is that I want to investiage the connection between the rate of representational drift in hippocampus and the transition from detailed episodic memory to more abstract gist-like memory. In this paper, they studied how the spatial memory of locations became more attracted to the gist or an average of all location over time. Here I would use this as an behavioral experiment and combine it with neuroimaging technique such as fMRI to track how neural representation of spatial memories correlate with gist-like transformation of the memory. The behavioral result we expect to see the increasing of gist-based bias of individual item memories as times go by. For the future plan, I would like to explore this bias to related to a direction of drift of memory representation in the brain.</p>
<p>Link to the paper : https://github.com/CP-PP8/Zeng2021/blob/main/original_paper/elife-65588-v3.pdf Link to the repository : https://github.com/CP-PP8/Zeng2021/tree/main Link to the paradigm : https://github.com/psyc-201/Zeng2021/blob/main/gist_bias_exp/index.html</p>
</section>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<p>The stimuli used in this study will be black dot presented on the screen. Each dot is corresponded to a name of different places such as hospital, school. The dot will be presented sequentially and location of each of them will be different on the screen. So participants need to remember the match between the dot location and the place it represents e.g.&nbsp;A hospital is a dot located on the upper right. The training phase will let participants to learn an association between the location and name of the place. They will have to learn a set of 6 dots-location pairings in total. The first phase of training is an exposure to dot-location pair. Participants will learn the association and proceed to next item by clicking on the screen. Each pair will be presented sequentially. There is no time-limit in this phase. Next, they will proceed to the second phase training, here they have to recall the location of dot cued by name of the place (university ?). After they respond, they will receive a feedback. If the response error is less than 80 pixel from true location, they will receive a feedback telling the correct location of that dot and proceed to the next dot. If they made a bigger error than 80 pixels, then they will have 2 more attempts to answer the correct answer. The location of the dot will be shown at feedback if they make 3 incorrect attempts. Lastly, they proceed to phase 3 of the training phase. In this phase, They have to recall each landmark consecutively and must have a smaller error than 80 pixels for all items to progress to the test phase. If not, they will go back to session 2 for more training. After the finish training phase 3. They will have to perform unrelated arithmetric problem to reduce an effect of longering memories before going into the test phase. Then they will have to return for another testing sessions and each participant will be allocated to different duration between test session 1 and 2 : at 1 day, 1 week and 1 month after the training phase. For each test trial, participants will be showned a dot of on screen and the name of a place. Then they will need to answer the location and the name are correctly matched. There will be one extra trial that asks participants to report an average location of all dots they learned during the training phase. Here, I plan to replicate experiment 1 in this study</p>
<section id="power-analysis" class="level3">
<h3 class="anchored" data-anchor-id="power-analysis">Power Analysis</h3>
<p>They do not report any effect size in the paper. On average, they have around 40 participants for each group. So the total number of subjects that we have to collect will be around 120-130 subjects to replicate the full effect size.</p>
</section>
<section id="planned-sample" class="level3">
<h3 class="anchored" data-anchor-id="planned-sample">Planned Sample</h3>
<p>90-100 subjects from UCSD psychology undergraduate students and separate them into 3 different groups Exclusion criteria =&gt; bad performance compared to group average : lower than 3 SD below average in any testing sessions (in either individual or gist memory trials) =&gt; bads performance compared to guessing : if any participants have guessed (having more than 267 pixels error in invidual memory condition and more than 270 pixels in gist memory condition) in at least 50% of trials of indvidual memory gist memory trial in either session =&gt; drop out of second session</p>
</section>
<section id="materials" class="level3">
<h3 class="anchored" data-anchor-id="materials">Materials</h3>
<p>The experiment will be built as exactly as described in Zeng et al.&nbsp;using JSPsych</p>
</section>
<section id="procedure-i-just-sent-an-email-to-corresponding-author-for-more-details-on-how-to-code-an-experiment.-i-will-put-in-more-details-when-i-get-more-information" class="level3">
<h3 class="anchored" data-anchor-id="procedure-i-just-sent-an-email-to-corresponding-author-for-more-details-on-how-to-code-an-experiment.-i-will-put-in-more-details-when-i-get-more-information">Procedure (I just sent an email to corresponding author for more details on how to code an experiment. I will put in more details when I get more information !)</h3>
<p>Experiment : During training phase 1, a dot with a size of …. pixels will be presented along the text displaying the landmark corresponding to the dot. For phase 2, the landmark text will be displared on the screen and participants need to click on the location that they think represent the dot. Nexy, the feedback will be shown and participants learned the correct location of a landamark. For training phase 3, the trial proceeds in the similar manner to phase 2 but there is no feedback. The testing session is also proceed in the same pattern as training phase 3 but there will be an additional trial asking for participants to respond for aan average location of all landmarks in the set they’ve just learned. The location of dots will be the same across participants. Only mapping between dot location and landmark name would change across participants, The behavioral response will be collected by recording the position (x,y) that participants click on the screen during each trials. Reaction time is also collected for possible additional analysis</p>
<p>Participants will be recruited online via SONA system. In session 1, they will have to finish 3 training phases and unrelated arithmetric task in order to start the testing phase. After they finish the 1st session, they would be asked to return for 2nd session at varied intervals. Here, they will receive a credit when they are done with 2 sessions.</p>
</section>
<section id="analysis-plan" class="level3">
<h3 class="anchored" data-anchor-id="analysis-plan">Analysis Plan</h3>
<p>Error measurement =&gt; individual item : the error would be calculated as the Euclidean distance from participant’s report to the correct location and then average across all 6 locations to get item memory error for each participant. =&gt; gist memory : there are 2 ways of estimating gist memory error. First, we would calculate the euclidean distance between reported gist and the true gist location. The second method is to caluclate reported gist by averaging over all participant’s response on individual memroy to get estimated gist. The we could calculate distance between two fo them just like the first method.</p>
<p>Bias measurement The bias would be defined as the difference between the Euclidean distance from true item location to true gist location and the Euclidean distance from reported item location to true gist location divided by the Euclidean distance from true item location to true gist location. If the bias is more than 0, it means that there is an attractive bias toward the gist location</p>
<p>Bias simulation</p>
<p>There are 2 simulation for bias here: item-only bias and item-gist bias. The item-only bias is simulated by using error for each items as the distance from the true location and simulate the angular distance uniformly from 0-360 degree. Each simulation run consists of 6 items and average bias will be calculated. Then we will run a simulation for 1000 runs and get average bias over all runs. Finally, we would iterate over participants and get populatio bias. For item-gist bias, they would be a slight adjustment on how we sample angular distance. Now, the distribution will not be uniform and probability on sampling each angle bin (we bin 360 deg. angular space into 200 bins) will be depending on how close it is to the reported center.</p>
<p>Statistics</p>
<p>To test how gist and item memory errors change over time, we would perform 3 (time interval : 24 hr, 1 week, 1 month) x 2 (item memory, gist memory) aligned ranks transformation ANOVA. Futheremore, we will use two-tailed Mann-Whitney tests to compare error change between groups To compare whether observed bias is different from simulated item-only bias over time, we conducted a 2 (session: Session 1 vs.&nbsp;Session 2) x 3 (delay groups: 24 hr, 1 week, and 1 month) ANOVA. Next we will use two-tailed paired t-tests for post-hoc comparison. Lastly, we will use the same statistical tests (2 x 3 ANOVA and two-tailed pair t-tests to determine whether observe bias become more similar simulated gist-based bias overtime.</p>
</section>
<section id="reliability-and-validity" class="level3">
<h3 class="anchored" data-anchor-id="reliability-and-validity">Reliability and validity</h3>
<p>The method to measure an error is calculating euclidean distance on x and y-axis. It has been used widely in spatial memory research and has a validity. However, the reliability in this study might be lower than other research as they only measure memory for each location once. So it is more likely to have a noisy estimation of memory from single measurement.</p>
<p>Normally, the measurement of memory bias can be vary. Some studies use a proportion of response that is biased toward other items. Other studies might flip the sign of error based on the direction of bias and calculate circular mean of error distribution and see whether a mean is significantly different from 0. In this study, they calculate bias by using the difference between the Euclidean distance from true item location to true gist location and the Euclidean distance from reported item location to true gist location divided by the Euclidean distance from true item location to true gist location. It is more similar to the first method but here they also scale bias so it should be affected less by any outliers. The only concern here is that the reliability might be low as previously mentioned. Another concern is that there is no baseline to compare bias. Therefore, they use simulated bias in order to compare whether the bias become closer to gist overtime.</p>
</section>
<section id="differences-from-original-study" class="level3">
<h3 class="anchored" data-anchor-id="differences-from-original-study">Differences from Original Study</h3>
<p>Explicitly describe known differences in sample, setting, procedure, and analysis plan from original study. The goal, of course, is to minimize those differences, but differences will inevitably occur. Also, note whether such differences are anticipated to make a difference based on claims in the original article or subsequent published research on the conditions for obtaining the effect.</p>
</section>
<section id="methods-addendum-post-data-collection" class="level3">
<h3 class="anchored" data-anchor-id="methods-addendum-post-data-collection">Methods Addendum (Post Data Collection)</h3>
<p>You can comment this section out prior to final report with data collection.</p>
<section id="actual-sample" class="level4">
<h4 class="anchored" data-anchor-id="actual-sample">Actual Sample</h4>
<p>Sample size, demographics, data exclusions based on rules spelled out in analysis plan</p>
</section>
<section id="differences-from-pre-data-collection-methods-plan" class="level4">
<h4 class="anchored" data-anchor-id="differences-from-pre-data-collection-methods-plan">Differences from pre-data collection methods plan</h4>
<p>Any differences from what was described as the original plan, or “none”.</p>
</section>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<section id="data-preparation" class="level3">
<h3 class="anchored" data-anchor-id="data-preparation">Data preparation</h3>
<p>Data preparation following the analysis plan.</p>
</section>
<section id="confirmatory-analysis" class="level3">
<h3 class="anchored" data-anchor-id="confirmatory-analysis">Confirmatory analysis</h3>
<p>The analyses as specified in the analysis plan.</p>
<p><em>Side-by-side graph with original graph is ideal here</em></p>
</section>
<section id="exploratory-analyses" class="level3">
<h3 class="anchored" data-anchor-id="exploratory-analyses">Exploratory analyses</h3>
<p>Any follow-up analyses desired (not required).</p>
</section>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<section id="summary-of-replication-attempt" class="level3">
<h3 class="anchored" data-anchor-id="summary-of-replication-attempt">Summary of Replication Attempt</h3>
<p>Open the discussion section with a paragraph summarizing the primary result from the confirmatory analysis and the assessment of whether it replicated, partially replicated, or failed to replicate the original result.</p>
</section>
<section id="commentary" class="level3">
<h3 class="anchored" data-anchor-id="commentary">Commentary</h3>
<p>Add open-ended commentary (if any) reflecting (a) insights from follow-up exploratory analysis, (b) assessment of the meaning of the replication (or not) - e.g., for a failure to replicate, are the differences between original and present study ones that definitely, plausibly, or are unlikely to have been moderators of the result, and (c) discussion of any objections or challenges raised by the current and original authors about the replication attempt. None of these need to be long.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>